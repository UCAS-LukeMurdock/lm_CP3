Array sorting algorithms can be categorized in various ways based on their approach and characteristics.
1. Based on Comparison:
Comparison-based Sorts:
These algorithms compare elements to determine their relative order. Examples include:
Bubble Sort: Repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order.
Selection Sort: Repeatedly finds the minimum element from the unsorted part and puts it at the beginning.
Insertion Sort: Builds the final sorted array one item at a time by repeatedly taking new elements and inserting them into the correct position in the already sorted part of the array.
Merge Sort: A divide-and-conquer algorithm that divides the unsorted list into n sublists, each containing one element, and then repeatedly merges sublists to produce new sorted sublists until there is only one sublist remaining.
Quick Sort: A divide-and-conquer algorithm that picks an element as a pivot and partitions the array around the picked pivot.
Heap Sort: A comparison-based sorting technique based on the Binary Heap data structure.
Non-comparison-based Sorts (Integer Sorts):
These algorithms do not rely on comparisons but instead use properties of the elements, often their numerical values or digits. Examples include:
Counting Sort: Sorts elements by counting the occurrences of each distinct element in the input array.
Radix Sort: Sorts integers by processing individual digits.
Bucket Sort: Divides the input array into a number of buckets, distributes the elements into the buckets, sorts each bucket, and then concatenates the sorted buckets. 
2. Based on Memory Usage:
In-place Sorts:
.
These algorithms sort the array by modifying the original array directly, requiring a minimal amount of extra memory (usually O(1) or O(log n)). Examples include Bubble Sort, Selection Sort, Insertion Sort, Heap Sort.
Not-in-place Sorts:
.
These algorithms require additional memory space proportional to the input size to store intermediate results during the sorting process. Examples include Merge Sort.
3. Based on Stability:
Stable Sorts:
.
These algorithms maintain the relative order of equal elements in the sorted output as they were in the original input. Examples include Merge Sort, Insertion Sort, Bubble Sort.
Unstable Sorts:
.
These algorithms do not guarantee the preservation of the relative order of equal elements. Examples include Quick Sort, Selection Sort, Heap Sort.
4. Based on Recursion:
Recursive Sorts:
.
Algorithms that use recursion in their implementation, such as Merge Sort and Quick Sort.
Iterative Sorts:
.
Algorithms that use iterative loops, such as Bubble Sort, Selection Sort, and Insertion Sort.
5. Hybrid Sorting Algorithms:
These algorithms combine multiple sorting techniques to leverage the strengths of each. An example is IntroSort, which typically starts with Quick Sort, switches to Heap Sort if recursion depth exceeds a certain level, and uses Insertion Sort for small partitions.




Selection:
    Takes the next element from the unsorted part and inserts it into its correct position in the already sorted part by shifting other elements.

Insertion:
    Finds the smallest element in the unsorted portion of the array and swaps it with the element at the current position.